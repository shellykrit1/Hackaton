# client.py

import socket
from typing import Tuple

from shared_protocol import (
    client_udp_offer_port,
    offer_unpack,
    request_pack,
    Request,
    server_payload_unpack,
    client_payload_pack,
    round_not_over,
    round_result_win,
    round_result_loss,
    round_result_tie,
    card_to_str,
    rank_to_game_value,
    round_result_to_str,
    receive_length_packet
)

# TCP connect timeout
connect_timeout_seconds = 5.0


def input_num_rounds() -> int:
    """
    ask user for the number of rounds (0-255) until valid input is given
    """
    while True:
        number_of_rounds = input("Enter number of rounds to play (0-255): ").strip()
        try:
            value = int(number_of_rounds)
        except ValueError:
            print("Invalid input. Please enter an integer between 0 and 255.")
            continue
        if value < 0 or value > 255:
            print("Invalid range. Please enter an integer between 0 and 255.")
            continue
        return value


def input_move() -> str:
    """
    ask user for a move: 'h' for hit or 's' for stand until valid input is given.
    """
    while True:
        move = input("Your move (h=hit, s=stand): ").strip().lower()
        if move in ("h", "s"):
            return move
        print("Invalid input. Please type 'h' for hit or 's' for stand.")


def listen_for_offer() -> Tuple[str, int, str]:
    """
    listen for UDP broadcast offers on a known UDP port.
    this uses blocking recvfrom() - not busy-waiting.
    """
    # UDP socket for receiving offers
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    # allow multiple clients to bind the same UDP port
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    # bind to the chosen offer port
    sock.bind(("", client_udp_offer_port))
    print("Client started, listening for offer requests...")

    while True:
        # wait for UDP packet
        data, (src_ip, src_port) = sock.recvfrom(1024)
        # parse Offer packet according to protocol
        offer = offer_unpack(data)
        if offer is None:
            continue
        # validate TCP port in offer
        port_tcp = int(offer.port_tcp)
        if not (1 <= port_tcp <= 65535):
            continue
        # parse server name from offer
        name_server = offer.name_server
        # close UDP socket after choosing a server
        sock.close()
        print(f"Received offer from {src_ip}")
        return src_ip, port_tcp, name_server


class ClientStats:
    """
    collect interesting statistics for one session.
    """

    def __init__(self) -> None:
        # overall results counters
        self.total_rounds = 0
        self.total_wins = 0
        self.total_losses = 0
        self.total_ties = 0
        self.total_player_busts = 0
        self.total_hits = 0
        self.sum_cards_received: list[int] = []
        self.num_cards_received: list[int] = []

    def update_counters_round(self, result: int, player_cards_received: int, busted: bool, hits: int,
                              cards_received: int) -> None:
        """
        update internal counters for the end of a round.
        """
        self.total_rounds += 1
        self.total_hits += hits
        self.sum_cards_received.append(player_cards_received)
        self.num_cards_received.append(cards_received)

        if busted:
            self.total_player_busts += 1
        if result == round_result_win:
            self.total_wins += 1
        elif result == round_result_loss:
            self.total_losses += 1
        else:
            self.total_ties += 1

    def summery_round_print(self) -> None:
        """
        print a summary after the session ends.
        """
        total_number_rounds = self.total_rounds
        win_rate = (self.total_wins / total_number_rounds) if total_number_rounds > 0 else 0.0
        print(f"Finished playing {total_number_rounds} rounds, win rate: {win_rate}")

        if total_number_rounds == 0:
            return

        bust_rate = self.total_player_busts / total_number_rounds
        avg_sum_cards = sum(self.sum_cards_received) / total_number_rounds
        avg_num_cards = sum(self.num_cards_received) / total_number_rounds

        # print(f"Statistics: \n)
        print(
            f"Statistics:\n"
            f"Wins={self.total_wins}, Losses={self.total_losses}, Ties={self.total_ties}\n"
            f"Number of player busts={self.total_player_busts} ({bust_rate:.2%})\n"
            f"Average player total amount cards={avg_sum_cards:.2f}\n"
            f"Average number of player's cards received per round={avg_num_cards:.2f}"
        )


def play_rounds(server_ip: str, server_port: int, name_team: str, rounds: int) -> ClientStats:
    """
    connect to the server over TCP and play "rounds" number of rounds.
    returns a ClientStats object with aggregated statistics for the session.
    """
    # create a statistics collector for the whole session
    statistics = ClientStats()
    # create a TCP socket and connect to the server
    conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn.settimeout(connect_timeout_seconds)  # prevent connect() from blocking forever
    conn.connect((server_ip, server_port))  # connect to server's TCP endpoint
    conn.settimeout(None)  # back to blocking mode for gameplay
    # send the initial Request packet
    conn.sendall(request_pack(Request(number_of_rounds=rounds, name_team=name_team)))
    # play the requested number of rounds
    for round_index in range(1, rounds + 1):
        print(f"\n--- Round {round_index}/{rounds} ---")
        # per round counters
        num_cards = 0
        num_hits = 0
        player_sum = 0
        dealer_sum = 0

        # the client reads 3 server payloads at the beginning of the round.
        for i in range(3):
            message = receive_length_packet(conn, 9)
            if message is None:
                conn.close()
                raise RuntimeError("Connection closed while receiving initial cards")

            server_payload = server_payload_unpack(message)  # parse the server payload
            # validate protocol - round not finished yet + a real card
            if server_payload is None or server_payload.round_result != round_not_over or server_payload.card_rank == 0:
                conn.close()
                raise RuntimeError("Protocol error: invalid initial payload")

            card_value = rank_to_game_value(server_payload.card_rank)
            if i < 2:
                print(
                    f"Player card received: {card_to_str(server_payload.card_rank, server_payload.card_suit)} (value={card_value})")
            else:
                print(
                    f"Dealer up card received: {card_to_str(server_payload.card_rank, server_payload.card_suit)} (value={card_value})")
                dealer_sum += card_value
            # first two cards are player's, third is dealer's up-card
            if i < 2:
                player_sum += card_value
                num_cards += 1
                print(f"Player sum cards: {player_sum}")

        round_result = None
        busted = False

        # player phase - keep asking for HIT/Stand until the round ends or player stands
        while True:
            move = input_move()
            if move == "h":
                num_hits += 1
                conn.sendall(client_payload_pack("Hittt"))  # send HIT decision to server
                message = receive_length_packet(conn, 9)
                if message is None:
                    conn.close()
                    raise RuntimeError("Connection closed after HIT")
                server_payload = server_payload_unpack(message)  # parse the server payload
                if server_payload is None:
                    conn.close()
                    raise RuntimeError("Protocol error after HIT")

                # normal HIT response - server sends another card if round not finished yet + a real card
                if server_payload.round_result == round_not_over and server_payload.card_rank != 0:
                    card_value = rank_to_game_value(server_payload.card_rank)
                    player_sum += card_value
                    num_cards += 1
                    print(f"Player card received: {card_to_str(server_payload.card_rank, server_payload.card_suit)} (value={card_value})")
                    print(f"Player sum cards: {player_sum}")
                    if player_sum > 21:
                        loss_message = receive_length_packet(conn, 9)
                        if loss_message is None:
                            conn.close()
                            raise RuntimeError("Connection closed while waiting for bust result")

                        server_payload_loss = server_payload_unpack(loss_message)  # parse the server payload
                        if server_payload_loss is None or server_payload_loss.round_result != round_result_loss:
                            conn.close()
                            raise RuntimeError("Protocol error: expected LOSS after bust")
                        print("Round result: LOSS")
                        round_result = round_result_loss
                        busted = True  # player busts
                        break

                    # player haven't busted, continue player decisions
                    continue

                conn.close()
                raise RuntimeError("Protocol error: unexpected payload after HIT")

            else:
                # stand - send decision and proceed to dealer phase
                conn.sendall(client_payload_pack("Stand"))
                print("Stand sent, waiting for dealer phase...")
                break

        # if the round already ended in player phase (bust)
        if round_result is not None:
            print(f"Round summary: player sum cards={player_sum}, dealer sum cards={dealer_sum}")
            statistics.update_counters_round(
                result=round_result,
                player_cards_received=player_sum,
                busted=busted,
                hits=num_hits,
                cards_received=num_cards,
            )
            continue

        # dealer phase - receive server payloads until dealer's done by the rules
        while True:
            message = receive_length_packet(conn, 9)
            if message is None:
                conn.close()
                raise RuntimeError("Connection closed during dealer phase")

            server_payload = server_payload_unpack(message)  # parse the server payload
            if server_payload is None:
                conn.close()
                raise RuntimeError("Protocol error during dealer phase")

            # print round result
            if server_payload.round_result in (round_result_win, round_result_loss, round_result_tie):
                print(f"Round result: {round_result_to_str(server_payload.round_result)}")
                round_result = server_payload.round_result
                break

            # dealer card payload if round not over and a real card
            if server_payload.round_result == round_not_over and server_payload.card_rank != 0:
                card_value = rank_to_game_value(server_payload.card_rank)
                dealer_sum += card_value
                print(f"Dealer card received: {card_to_str(server_payload.card_rank, server_payload.card_suit)} (value={card_value})")
                continue

            conn.close()
            raise RuntimeError("Protocol error: unexpected payload during dealer phase")

        print(f"Round summary: player sum cards={player_sum}, dealer sum cards={dealer_sum}")
        # update session statistics after round is over
        statistics.update_counters_round(
            result=round_result if round_result is not None else round_result_loss,
            player_cards_received=player_sum,
            busted=False,
            hits=num_hits,
            cards_received=num_cards,
        )

    # close TCP connection after all rounds
    conn.close()
    return statistics


def main() -> None:
    name_team = "ShellyOhadTeam"

    while True:
        try:
            rounds = input_num_rounds()
            server_ip, server_port, name_server = listen_for_offer()
            statistics = play_rounds(server_ip, server_port, name_team, rounds)
            statistics.summery_round_print()

        except KeyboardInterrupt:
            print("\nInterrupted by user. Returning to listening...\n")
            continue

        except (socket.timeout, OSError):
            print("Connection failed. Returning to listening...\n")
            continue

        except Exception as e:
            print(f"Error occurred: {e}. Returning to listening...\n")
            continue


if __name__ == "__main__":
    main()
